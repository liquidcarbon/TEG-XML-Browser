# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/03_TEG_XML_Parser.ipynb.

# %% auto 0
__all__ = ['TEGXMLProcessor', 'unstringify', 'xml_unstringify']

# %% ../notebooks/03_TEG_XML_Parser.ipynb 5
from collections import abc
from loguru import logger as log
import ast
import json
import os
import re
import sys
import xmltodict 

# %% ../notebooks/03_TEG_XML_Parser.ipynb 9
#| code-fold: true
class TEGXMLProcessor:
    """Pipeline for TEG6s XML processing."""

    ROOT_TAG = bytes("Cartridge", encoding="utf-8")  # assumption that this will be true
  
    def __init__(
        self,
        filepath: str  # path to input XML file
    ):
        self.filepath = filepath
        self.read_xml()

    def read_xml(self):
        """Read raw contents of the file."""
        try:
            with open(self.filepath, "rb") as f:
                self.contents = f.read()
            self.raw_length = len(self.contents)
            log.info(f"Read {self.raw_length:,d} bytes of raw XML data")
        except Exception as e:
            log.error(f"unable to read file: {e}")

    def get_content_from_sharepoint(self):
        raise NotImplementedError

    def find_xml_offsets(self):
        """Scans for XML fragments."""
        xml_open_bytes = [x.start() for x in re.finditer(b"<\?xml", self.contents)]
        xml_close_bytes = [x.end() for x in re.finditer(self.ROOT_TAG+b">", self.contents)]
        if len(xml_open_bytes) != len(xml_close_bytes):
            log.error("XML heads not equal XML tails")
        else:
            xml_offsets = [(start, end) for start, end in zip(xml_open_bytes, xml_close_bytes)]
            log.info(f"found {len(xml_offsets)} XML fragment(s)")
            return xml_offsets

    def parse(self):
        if self.contents.startswith(b"<?xml"):
            _to_parse = self.contents
        else:
            offsets = self.find_xml_offsets()
            start, end  = offsets[-1]  # this is an ASSUMPTION
            _to_parse = self.contents[start:end]
        try:
            self.d = xmltodict.parse(
                _to_parse,
                attr_prefix="",
                postprocessor=xml_unstringify,
            )
            self.id = self.d["Cartridge"]["CartridgeResult"]["TestResultID"]
            log.info("XML parsed")
        except Exception as e:
            log.error(f"Nope: {e}")

    def pop_lists(self):
        """Recursively iterate through dictionary and pop all lists into a separate object."""
        self.lists = {}
        def walk_and_pop(nested_dict, path=tuple()):
            for key, value in nested_dict.copy().items():
                nested_path = path + (key,)
                if isinstance(value, list):  # is it a list? pop it
                    self.lists[nested_path] = nested_dict.pop(key)
                elif isinstance(value, abc.Mapping):  # https://stackoverflow.com/a/35691011/9511034
                    walk_and_pop(value, path=nested_path)  # is it a dict? go deeper
                else:
                    continue
        walk_and_pop(self.d)
        return

    def save_jsons(self):
        """Saves parsed XML data in JSON files."""
        metadata_filepath = self.filepath.rstrip(".xml") + "_metadata.json"
        self.save_metadata_json(output_filepath=metadata_filepath)
        
    def save_metadata_json(
        self,
        output_filepath: str  # path to output file
    ):
        """Saves metadata as a JSON file."""
        _output = json.dumps(self.d, indent=4)
        with open(output_filepath, "w") as f:
            f.write(_output)
        log.info(f"wrote {len(_output):,d} bytes to {output_filepath}")

def unstringify(value):
    """Converts stringified numbers to integers or floats."""
    try:
        value = ast.literal_eval(val)
    except:
        pass
    return value


def xml_unstringify(path, key, value):
    """Used as a callable for `xmldict.parse`.
    
    Casts numbers that appears as strings in XML back to integers or floats.
    """
    if value == "true":
        value = "True"
    if value == "false":
        value = "False"
    return key, unstringify(value)
